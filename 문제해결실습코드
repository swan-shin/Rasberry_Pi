SL010910

원래 스플릿의 결과는 list

for target in iterable(집합형)

iterable에서 target으로 뽑아낸다는 것
[ㅁ for target in it]

ex) [x+1 for x in it]

[input() for i in range(N)] N줄에 걸쳐서 입력 받겠다.
[int(input()) for i ...]
[input().split for i ...] N줄에 걸쳐 여러 문자열을 받겠다.

[[int(n) for ]]

문제를 파악하고, 접근해야 할지

문제 예시를 종이에 적어가면서 기각적으로 구상
구분 될만한 동작 구현 표시

1. 이전 풀이했던 유사한 문제, 알고리즘 기법 있다면 그 형태로 접근
2. 문제의 설명을 그대를 옮겨 적고, 입력 예를 풀이하면서 해결 방안 모색
3. 실제 예를 여러 가지 적어서 그 중에서 규칙성을 발견하여 일반화 함(조건문/수식 등)
4. 전체를 순회하면서 단순하게 접근해서 풀 수 있는지 검토(배열 전체 순회, 모든 경우 풀이)
5. 반대로 접근하면 좀더 쉽게 풀릴 수 있는지 검토

3단계
6. 코드 구현 및 디버깅 염두에 두고, 문제풀이 단계 구분
7. 단계별 접근 방법 중 핵심적인 사항(조건문, 수식 등)은 손으로 적어, 코드 구현 시 혼동 방지
8. 추가적인 테스트벡터를 입력하여 위의 방법이 오류 없이 동작하는지의 여부를 검증

9. 단계별 코드 구현

파이썬 interpreter -> 줄 수가 짧을 수록 효율이 좋아짐


def add(a,b): return a+b

def f1():
    print('f1')
f1

def f2(a, b):
    c= a + b
    print(a, b, c)
    return c

print(f2(3,4))
--------------------------------------------------가장 가까운 수 출력----------------------------------------------------
arr = [float(x) for x in input('값들을 입력해주세요>>>').split()]
# dis [원래수, 차]
dis = [[x, abs(x-3.5)] for x in arr]
# 3.5와 가장 가까운 수: 차가 가장 작고 같다면 원래 수가 작은 것.
sol1 = min(dis)
print(dis)
print(sol1)

# 예제 값) 14 -7 -1 3.7 5.4 6 3.3

----------------------------------------------------전자레인지 문제------------------------------------------------------
T = int(input('전자레인지 작동시간 입력(정수) >>> '))
'''
버튼 A는 5분, B는 1분, C는 10초
T는 초단위 표시 -> A, B, C 3개의 버튼을 적절히 눌러서 그 시간의 합이 정확히 초가 되도록 해야 한다.
단1) A, B, C를 누른 횟수의 합은 항상 최소
단2) 234초와 같이 3개의 버튼으로 T초를 맞출 수 없을 경우 음수 -1을 첫 줄에 출력
'''
# idea1: 분은 초로 통일

A, B, C = 300, 100, 10

r1 = T//300
r2 = (T % A) // B
r3 = (T % A % B)// C

# r1, r2, r3 = T//300, (T%300)//60, (T%300%60)//10

print(-1) if T%10 else print(r1, r2, r3)


----------------------------------------------------주차 요금------------------------------------------------------

'''
주차 시간이 10분 미만 무료
'''
n= int(input())
arr = [int(input()) for i in range(n)]

# 누적값 합 sol
sol = 0

for time in arr:
    if time<10:fee=0
    elif 10<= time <=30: feel = 500
    else: # 30분초과
        time -= 30
        fee = 500 + time // 10*300
        if time%10 : fee+= 300
# 코드 줄이기 idea: fee = 500 + (time-30)//10*300 + (300 if time%10 else 0)
# fee = 500 + ((time-31)//10 + 1) * 300
        if fee>50000: fee = 50000
    sol+= fee

print(sol)
# 정올시 주차장, 
# 주차시간이 10분 미만 > 무료
# 10분 이상 ~ 30분 이하 > 500원
# 30분 초과하면 30분 요금에 30분 초과분에 대한 요금을 10분에 300원씩 받음.
# 그리고 하루 최대 주차요금은 한 대당 50,000을 넘을 수 없다. 이것은 정올시에서 지정한 것이다.

# 하루에 100대를 주차할 수 있는 주차장에 하루 동안 주차했던 차량 수와, 각 주차시간이 주어지면 하루 총 주차요금을 구하는 프로그램을 작성

'''
1. 10분 미만 무료
10분 

'''

if time < 10:
    fee = 0
elif 10 <= time <= 30:
    fee = 500
    
N = int(input())
l = [int(x) for x in input().split()]

# arr = [[i+1], l[i] for i in range(N)]

arr = list(enumerate(l, 1))
#enumerate 한 번 알아보기

# 점수는 내림차순, 동일하면 id 작은 것(오름차순)
arr.sort(key = lambda x:(-x[1], x[0])

'''
N명의 점수 상위 3명 출력
내림차순 정렬 and 상위 0, 1, 2 index 출력

N= '학생 수' (4<= N <= 30,000)
둘째 줄에는 N개의 점수가 공백으로 구분되어 ID 순으로 주어짐(각 점수는 0 이상 10억 이하)
맨 먼저 입력된 점수는 ID가 1인 학생의 점수, 이후부터 순서대로 ID 1씩 증가
'''

# 파이썬 권고 사항 if m==0: >> 이것 보다는 if m:  빈 리스트 (), [], null -> false 이런 부분 판단해서 if (True) 문 작성

------------------------------------------------------문제풀이 정답--------------------------------------------------------------

...
# [sol 1]
N, P = [ int(x) for x in input().split() ]
 
if P <= N//2:
    if P % 2 == 1 : print(P+1, N-P, N-P+1)
    else : print(P-1, N-P+1, N-P+2)
else :
    if P % 2 == 1: print(N-P, N-P+1, P+1) 
    else: print(N-P+1, N-P+2, P-1)
 
# [sol 2]
N, P = [ int(x) for x in input().split() ]
 
if P % 2 : print(*sorted([ P+1, N-P, N-P+1 ]))
else : print(*sorted([ P-1, N-P+1, N-P+2 ]))
...
 
# [sol 3]
 
N, P = [ int(x) for x in input().split() ]
 
x = P % 2
print(*sorted([(P-1) + 2*x, (N-P+1) - x, (N-P+2) - x]))
/**************************************************************
    Problem: 5886
    User: SWT01001
    Language: Python
    Result: Accepted
    Time:27 ms
    Memory:26800 kb
****************************************************************/

'''
# [sol 1]
arr = [ float(x) for x in input().split() ]
 
arr.sort()
dis = [ abs(x-3.5) for x in arr ]
sol1 = arr[ dis.index(min(dis)) ]
sol2 = arr[ dis.index(max(dis)) ]
 
print('{:f} {:f}'.format(sol1, sol2))
# print(f'{sol1:f} {sol2:f}') 
# print('%f %f' % (sol1, sol2))
'''
 
 
# [sol 2]
arr = [ float(x) for x in input().split() ]
 
dis = [ [x, abs(x-3.5)] for x in arr ]
sol1 = min(dis, key=lambda x: (x[1],x[0]))[0]
sol2 = max(dis, key=lambda x: (x[1],-x[0]))[0]
 
print(f'{sol1:f} {sol2:f}')
/**************************************************************
    Problem: 5884
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:28 ms
    Memory:26800 kb
****************************************************************/

T = int(input())
 
A, B, C = 300, 60, 10
r1, r2, r3 = T//A, (T%A)//B, (T%A%B)//C
 
if T%C : print(-1)
else : print(r1, r2, r3)  
/**************************************************************
    Problem: 5888
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:26 ms
    Memory:26800 kb
****************************************************************/

n = int(input())
arr = [ int(input()) for i in range(n) ]
  
sol = 0
for time in arr:
    if time<10: fee=0
    elif 10<=time<=30: fee=500
    else: # 30분 초과일경우
        # 10분당 300원 추가요금 부여
        #time -= 30
        #fee = 500 + time//10*300
        #if time%10 : fee +=300
          
        #fee = 500 + (time -30)//10 * 300 + ( 300 if time%10 else 0 )
  
        fee = 500 + ((time-31)//10 +1)*300
          
        if fee>50000: fee=50000
    sol += fee
  
print(sol)
/**************************************************************
    Problem: 5885
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:34 ms
    Memory:26800 kb
****************************************************************/


N = int(input())
l = [ int(x) for x in input().split() ]
 
#arr = list(enumerate(l, 1))
#arr.sort(key=lambda x: (-x[1], x[0]))
 
arr = sorted( enumerate(l, 1), key=lambda x: (-x[1], x[0]) )
 
print(arr[0][0], arr[1][0], arr[2][0])
/**************************************************************
    Problem: 5891
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:67 ms
    Memory:34404 kb
****************************************************************/ 사과

'''
# [sol 1]
N = int(input())
arr = [ [int(x) for x in input().split()] for _ in range(N) ]
 
sol = 0
for x, y in arr:
    sol += y%x
print(sol)
'''
 
 
# [sol 2]
N = int(input())
arr = [ [int(x) for x in input().split()] for _ in range(N) ]
 
sol = [ y%x for x, y in arr ]
print(sum(sol))
 
/**************************************************************
    Problem: 5890
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:36 ms
    Memory:26800 kb
****************************************************************/ 가장 가까운 짝수인 7의 배수

N = int(input())
 
a, b = divmod(N, 14)
if N<=14 : sol = 14
elif b>7 : sol = a*14 + 14
else : sol = a*14
print(sol)
/**************************************************************
    Problem: 5883
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:28 ms
    Memory:26800 kb
****************************************************************/

'''
# [sol 1]
N, Sum = [ int(x) for x in input().split() ]
 
tot = (1 + N) * N // 2
lost = tot - Sum
d, m = divmod(lost, 2)
 
if m == 0 :
    print('Error')
elif d % 2 == 0 :
    print('Error')
elif d < 1 or d > (N - 1) :
    print('Error')
else :
    print(d, d + 1)
'''
 
# [sol 2]
N, Sum = [ int(x) for x in input().split() ]
 
tot = (1 + N) * N // 2
lost = tot - Sum
d, m = divmod(lost, 2)
 
if m and d % 2 and 1 <= d < N :
    print(d, d+1)
else:
    print('Error')  
/**************************************************************
    Problem: 5962
    User: SWT01001
    Language: Python
    Result: Accepted
    Time:31 ms
    Memory:26800 kb
****************************************************************/ 찢어진 책

'''
# [sol 1]
def get_root(num): #숫자근 얻기
    while num >= 10:
        num = sum([int(x) for x in str(num)])
    return num
 
N = int(input())
arr = [ int(input()) for _ in range(N)]
sol, max_root = 0, 0
for x in arr:
    root = get_root(x)
    if max_root < root :
        max_root, sol = root, x
    elif max_root == root :
        sol = min(sol, x)
print(sol)
 
 
# [sol 2]
def get_root(num): 
    while num >= 10:
        num = sum([int(x) for x in str(num)])
    return num
 
N = int(input())
arr = sorted([ int(input()) for _ in range(N)])
d = [ get_root(x) for x in arr ]
sol = arr[ d.index(max(d)) ]
print(sol)
 
'''
 
 
# [sol 3]
def get_root(num): 
    while num >= 10:
        num = sum([int(x) for x in str(num)])
    return num
 
N = int(input())
arr = [ int(input()) for _ in range(N)]
d = [ [x, get_root(x)] for x in arr ]
sol = max(d, key=lambda x:(x[1], -x[0]))
print(sol[0])
 
/**************************************************************
    Problem: 5904
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:36 ms
    Memory:26800 kb
****************************************************************/ 숫자근

# [sol 1]
'''
s = input()
sol = 10
for i in range(1, len(s)):
    if s[i]==s[i-1]: sol += 5
    else: sol +=10
print(sol)
'''
 
# [sol 2]
s= input()
sol=0
prev= 0
for cur in s:
    if cur == prev : sol += 5
    else: sol += 10
    prev = cur
print(sol)
 
     
 
 
/**************************************************************
    Problem: 5897
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:30 ms
    Memory:26800 kb
****************************************************************/ 그릇

K = int(input()) 
N = int(input()) 
info = [ input().split() for _ in range(N) ] 
arr = [ [int(t), z] for t,z in info ] 
 
tot=0
for t, z in arr:
    tot += t
    if tot>210 : break
    if z=='T':       
        #K += 1
        #if K == 9 : K=1
        K = (K%8) + 1
 
print(K) 
 
/**************************************************************
    Problem: 5887
    User: SWT01007
    Language: Python
    Result: Accepted
    Time:26 ms
    Memory:26800 kb
****************************************************************/ 폭탄 돌리기
